{% extends "base.html" %}

{% block navigation %}
{% include 'components/client_navigation.html' %}
{% endblock %}

{% block title %}Download Certificate - {{ event.event_name }}{% endblock %}

{% block head %}
<!-- Certificate Styling with A4 Preview Support -->
<style>
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    .loading-spinner {
        display: inline-block;
        width: 18px;
        height: 18px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: #ffffff;
        animation: spin 1s linear infinite;
    }
    
    .download-btn {
        background: #2563eb;
        transition: background-color 0.2s;
    }
    
    .download-btn:hover {
        background: #1d4ed8;
    }
    
    .download-btn:disabled {
        background: #9ca3af;
        cursor: not-allowed;    }
    
    /* Hidden certificate content for processing */
    #certificate-preview-frame {
        /* Off-screen but rendered for processing */
        position: absolute !important;
        left: -9999px !important;
        top: 0 !important;
        visibility: hidden !important;
        width: auto !important;
        height: auto !important;
    }
    
    #certificate-content {
        /* Ensure content can be processed even when off-screen */
        width: auto !important;
        height: auto !important;
        display: block !important;
        visibility: visible !important;
        overflow: visible !important;
    }    /* Modal Styles for Floating Iframe Effect */
    #certificate-preview-modal {
        backdrop-filter: blur(4px);
    }
    
    /* Certificate as direct floating iframe - no container wrapper */
    #modal-certificate-content {
        overflow: visible !important;
        border-radius: 8px;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        transition: transform 0.3s ease;
    }
    
    /* Ensure no extra spacing or borders around certificate */
    #modal-certificate-content > div:not(#modal-loading-placeholder):not(button) {
        margin: 0;
        padding: 0;
        border: none;
        border-radius: 8px;
        overflow: hidden;
    }
    
    /* Floating close button styling */
    #modal-certificate-content button {
        backdrop-filter: blur(8px);
        border: 2px solid rgba(255, 255, 255, 0.2);
    }
    
    /* Responsive adjustments for smaller screens */
    @media (max-width: 768px) {
        #certificate-preview-modal {
            padding: 2rem 1rem;
        }
    }

    /* Loading state */
    .certificate-loading {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 300px;
        background: #f8f9fa;
        border-radius: 8px;
    }
</style>
{% endblock %}

{% block content %}
<div class="min-h-screen bg-gray-50 py-8">
    <div class="max-w-4xl mx-auto px-4">
        <!-- Simple Header -->
        <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-900 mb-2">Certificate Download</h1>
            <p class="text-lg text-gray-600">{{ event.event_name }}</p>
        </div>

        {% if error %}
        <!-- Simple Error State -->
        <div class="bg-white border border-red-200 rounded-lg p-6 mb-6 shadow-sm">
            <div class="flex items-center">
                <svg class="w-6 h-6 text-red-600 mr-3" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L9 10.414l1.293-1.293a1 1 0 001.414 1.414L11.414 12l1.293 1.293a1 1 0 01-1.414 1.414L10 13.414l-1.293 1.293a1 1 0 01-1.414-1.414L8.707 12 7.414 10.707a1 1 0 011.414-1.414L10 10.586l1.293-1.293z" clip-rule="evenodd"/>
                </svg>
                <div>
                    <h3 class="text-lg font-semibold text-red-800">Certificate Not Available</h3>
                    <p class="text-red-700 mt-1">{{ error }}</p>
                </div>
            </div>
            <div class="mt-6 flex gap-3">
                <a href="/client/events" class="inline-flex items-center px-4 py-2 bg-gray-900 text-white rounded-lg font-medium hover:bg-gray-800">
                    <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z" clip-rule="evenodd"/>
                    </svg>
                    Back to Events
                </a>
                <a href="/client/dashboard" class="inline-flex items-center px-4 py-2 bg-white text-gray-700 border border-gray-300 rounded-lg font-medium hover:bg-gray-50">
                    <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z" clip-rule="evenodd"/>
                    </svg>
                    Dashboard
                </a>
            </div>
        </div>
        {% else %}        <!-- Certificate Actions -->
        <div class="bg-white border border-gray-200 rounded-lg shadow-sm mb-8">
            <div class="border-b border-gray-200 px-6 py-4">
                <h2 class="text-xl font-semibold text-gray-900">Your Certificate</h2>
                <p class="text-gray-600">Preview or download your certificate</p>
            </div>
            <div class="p-6">
                <!-- Action Buttons -->
                <div class="text-center space-y-4">
                    <!-- Preview Button -->
                    <button id="preview-certificate-btn" 
                            class="bg-gray-100 hover:bg-gray-200 text-gray-800 px-8 py-3 rounded-lg text-lg font-medium inline-flex items-center gap-2 shadow-sm hover:shadow-md transition-all duration-200 mr-4" 
                            onclick="openPreviewModal()">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M10 12a2 2 0 100-4 2 2 0 000 4z"/>
                            <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd"/>
                        </svg>
                        Preview Certificate
                    </button>
                    
                    <!-- Download Button -->
                    <button id="download-certificate-btn" 
                            class="download-btn text-white px-8 py-3 rounded-lg text-lg font-medium inline-flex items-center gap-2 shadow-sm hover:shadow-md transition-all duration-200" 
                            onclick="downloadCertificate()">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd"/>
                        </svg>
                        Download Certificate
                    </button>
                    
                    <div id="status-message" class="mt-4 p-3 rounded-lg text-center font-medium hidden"></div>
                </div>
                  <!-- Hidden Certificate Content for Processing - Off-screen but rendered -->
                <div id="certificate-preview-frame" style="position: absolute; left: -9999px; top: 0; visibility: hidden;" data-orientation="landscape">
                    <div id="certificate-content" style="width: auto; height: auto;">
                        <div class="certificate-loading">
                            <div class="text-center p-8">
                                <svg class="w-12 h-12 mx-auto mb-4 text-gray-300" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd"/>
                                </svg>
                                <p class="text-lg font-medium">Loading certificate template...</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div><!-- Simple Instructions -->
        <div class="bg-white border border-gray-200 rounded-lg p-6 shadow-sm mb-8">
            <h3 class="text-lg font-semibold text-gray-900 mb-4">Instructions</h3>
            <ul class="space-y-2 text-gray-700">
                <li class="flex items-start">
                    <span class="w-2 h-2 bg-blue-500 rounded-full mt-2 mr-3 flex-shrink-0"></span>
                    Click the download button to generate your PDF certificate
                </li>
                <li class="flex items-start">
                    <span class="w-2 h-2 bg-blue-500 rounded-full mt-2 mr-3 flex-shrink-0"></span>
                    The file will be saved to your Downloads folder
                </li>
                <li class="flex items-start">
                    <span class="w-2 h-2 bg-blue-500 rounded-full mt-2 mr-3 flex-shrink-0"></span>
                    You can print or share the certificate as needed
                </li>
            </ul>
        </div>

        <!-- Simple Navigation -->
        <div class="text-center">
            <div class="inline-flex gap-4">
                <a href="/client/events" class="inline-flex items-center px-4 py-2 bg-gray-900 text-white rounded-lg font-medium hover:bg-gray-800">
                    <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z" clip-rule="evenodd"/>
                    </svg>
                    Back to Events
                </a>
                <a href="/client/dashboard" class="inline-flex items-center px-4 py-2 bg-white text-gray-700 border border-gray-300 rounded-lg font-medium hover:bg-gray-50">
                    <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z" clip-rule="evenodd"/>
                    </svg>
                    Dashboard
                </a>
            </div>        </div>
        {% endif %}
    </div>
</div>

<!-- Certificate Preview Modal as Floating Iframe -->
<div id="certificate-preview-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
    <!-- Certificate Content as Direct Floating Window (No Container) -->
    <div id="modal-certificate-content" class="relative bg-white shadow-2xl transform-gpu" style="transform-origin: center center;">
        <!-- Floating Close Button -->
        <button onclick="closePreviewModal()" class="absolute top-3 right-3 z-20 bg-black bg-opacity-80 hover:bg-opacity-100 text-white rounded-full p-2 transition-all duration-200 shadow-lg">
            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/>
            </svg>
        </button>
        
        <!-- Loading State (will be replaced with certificate) -->
        <div id="modal-loading-placeholder" class="w-96 h-64 flex justify-center items-center text-gray-500 bg-white rounded-lg">
            <div class="text-center p-8">
                <svg class="w-12 h-12 mx-auto mb-4 text-gray-300" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd"/>
                </svg>
                <p class="text-lg font-medium">Loading certificate preview...</p>
            </div>
        </div>
    </div>
</div>

{% if not error %}
<!-- Certificate Generation JavaScript -->
<script>
// Global variables for certificate data (define first!)
const certificateData = {
    eventId: '{{ event.event_id }}',
    eventName: '{{ event.event_name }}',
    participantName: '{{ student.full_name or "Student Name" }}',
    department: '{{ student.department or "Department" }}',
    {% if team_info and team_info.team_name %}
    teamName: '{{ team_info.team_name }}',
    {% endif %}
    eventDate: '{{ event.start_datetime.strftime("%B %d, %Y") if event.start_datetime else "Event Date" }}',
    certificateId: '{{ certificate.certificate_id if certificate else "CERT-ID" }}',
    enrollmentNo: '{{ student.enrollment_no }}'
};

// Wait for page to load
document.addEventListener('DOMContentLoaded', function() {
    console.log('üéì Certificate download page loaded');
    console.log('üìä Certificate Data:', certificateData);
    
    // Load certificate template first
    loadCertificateTemplate();
    
    // Check if libraries are ready
    if (typeof window.checkCertificateLibraries === 'function') {
        const isReady = window.checkCertificateLibraries();
        if (!isReady) {
            showStatus('Certificate system is loading... Please wait.', 'info');
            
            // Listen for library ready event
            window.addEventListener('certificateLibrariesReady', function(event) {
                if (event.detail.ready) {
                    showStatus('Certificate system ready!', 'success');
                    setTimeout(() => hideStatus(), 2000);
                } else {
                    showStatus('Some certificate libraries failed to load. Download may not work properly.', 'error');
                }
            });
        }
    }
});

// Load certificate template from the event's template path
async function loadCertificateTemplate() {
    try {
        showStatus('Loading certificate template...', 'info');
        
        // Check if template path is configured
        const templatePath = '{{ event.certificate_template }}';
        if (!templatePath || templatePath === 'None') {
            throw new Error('No certificate template configured for this event');
        }
        
        console.log(`üìÑ Loading template from: ${templatePath}`);
        
        // Load template content from API
        const response = await fetch(`/client/api/certificate-template/${certificateData.eventId}`, {
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        if (!response.ok) {
            throw new Error(`Failed to load template: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        if (!data.success) {
            throw new Error(data.message || 'Failed to load certificate template');
        }
        
        console.log('‚úÖ Template data received:', data);        // Process template with student data
        const processedTemplate = processTemplateContent(data.template_content, data.placeholder_data);
        
        // Load the processed template into the preview
        document.getElementById('certificate-content').innerHTML = processedTemplate;
        
        // Check for and inject extracted styles
        const certificateWrapper = document.querySelector('.certificate-wrapper[data-styles]');
        if (certificateWrapper) {
            const encodedStyles = certificateWrapper.getAttribute('data-styles');
            if (encodedStyles) {
                const styles = decodeURIComponent(encodedStyles);
                
                // Create a style element and inject it into the document head
                const styleElement = document.createElement('style');
                styleElement.id = 'certificate-styles';
                styleElement.textContent = styles;
                
                // Remove any existing certificate styles
                const existingStyles = document.getElementById('certificate-styles');
                if (existingStyles) {
                    existingStyles.remove();
                }
                
                // Inject new styles
                document.head.appendChild(styleElement);
                console.log('‚úÖ Injected certificate styles into document head');
                console.log('üé® Injected styles:', styles.substring(0, 200) + '...');
            }
        }
        
        console.log('üìã Processed template length:', processedTemplate.length);
        console.log('üìã Certificate content after loading:', document.getElementById('certificate-content').innerHTML.substring(0, 200) + '...');
        
        // Detect and apply orientation after template loads
        setTimeout(() => {
            detectAndApplyOrientation();
            console.log('üîÑ Template processing complete');
        }, 500);
        
        hideStatus();
        console.log('‚úÖ Certificate template loaded and processed successfully');
        
    } catch (error) {
        console.error('‚ùå Failed to load certificate template:', error);
        document.getElementById('certificate-content').innerHTML = `
            <div class="text-center text-red-600 p-8">
                <svg class="w-12 h-12 mx-auto mb-4" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                </svg>
                <h3 class="text-lg font-semibold mb-2">Template Loading Error</h3>
                <p class="text-sm">${error.message}</p>
                <p class="text-xs text-gray-500 mt-2">Template Path: {{ event.certificate_template }}</p>
            </div>
        `;
        showStatus(`Template error: ${error.message}`, 'error');
    }
}

// Scale certificate content to fit properly in preview frame
function scaleCertificateContent() {
    const certificateContent = document.getElementById('certificate-content');
    const previewFrame = document.getElementById('certificate-preview-frame');
    
    if (!certificateContent || !previewFrame) {
        return;
    }
    
    // Remove any existing transforms
    certificateContent.style.transform = '';
    
    // Get the actual content dimensions
    const contentChild = certificateContent.firstElementChild;
    if (!contentChild) {
        return;
    }
    
    // Wait for rendering and then calculate scale
    setTimeout(() => {
        const frameRect = previewFrame.getBoundingClientRect();
        const contentRect = contentChild.getBoundingClientRect();
        
        if (frameRect.width > 0 && frameRect.height > 0 && contentRect.width > 0 && contentRect.height > 0) {
            // Calculate scale to fit both width and height
            const scaleX = (frameRect.width - 40) / contentRect.width; // 40px padding
            const scaleY = (frameRect.height - 40) / contentRect.height; // 40px padding
            const scale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down
            
            if (scale < 1) {
                certificateContent.style.transform = `scale(${scale})`;
                certificateContent.style.transformOrigin = 'center center';
                console.log(`üìè Scaled certificate content by ${scale.toFixed(3)} to fit preview`);
            } else {
                console.log('üìè Certificate content fits naturally in preview');
            }
        }
    }, 200);
}

// Detect certificate orientation and apply appropriate styling
function detectAndApplyOrientation() {
    const certificateContent = document.getElementById('certificate-content');
    const previewFrame = document.getElementById('certificate-preview-frame');
    
    if (!certificateContent || !previewFrame) {
        console.warn('Certificate elements not found for orientation detection');
        return;
    }
    
    // Look for orientation hints in the template
    let isLandscape = true; // Default to landscape
    
    // Check CSS @page rules in the content
    const styleElements = certificateContent.querySelectorAll('style');
    let foundPageRule = false;
    
    styleElements.forEach(style => {
        const cssText = style.textContent || style.innerText;
        if (cssText.includes('@page')) {
            foundPageRule = true;
            if (cssText.includes('size:') && cssText.includes('portrait')) {
                isLandscape = false;
                console.log('üìÑ Detected portrait orientation from @page CSS rule');
            } else if (cssText.includes('size:') && cssText.includes('landscape')) {
                isLandscape = true;
                console.log('üìÑ Detected landscape orientation from @page CSS rule');
            } else if (cssText.includes('A4 portrait')) {
                isLandscape = false;
                console.log('üìÑ Detected portrait orientation from CSS comment');
            }
        }
    });
    
    // If no explicit @page rule found, try to detect from dimensions
    if (!foundPageRule) {
        // Create a temporary element to measure the natural size
        const tempDiv = document.createElement('div');
        tempDiv.style.position = 'absolute';
        tempDiv.style.left = '-9999px';
        tempDiv.style.top = '0';
        tempDiv.style.width = 'auto';
        tempDiv.style.height = 'auto';
        tempDiv.innerHTML = certificateContent.innerHTML;
        
        document.body.appendChild(tempDiv);
        
        // Wait a moment for rendering
        setTimeout(() => {
            const rect = tempDiv.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
                const aspectRatio = rect.width / rect.height;
                
                // A4 landscape ratio is ~1.414, portrait is ~0.707
                if (aspectRatio > 1.2) {
                    isLandscape = true;
                    console.log(`üìÑ Detected landscape orientation from aspect ratio: ${aspectRatio.toFixed(2)}`);
                } else if (aspectRatio < 0.9) {
                    isLandscape = false;
                    console.log(`üìÑ Detected portrait orientation from aspect ratio: ${aspectRatio.toFixed(2)}`);
                }
            }
            
            document.body.removeChild(tempDiv);
        }, 100);
    }
      // Apply orientation information (for PDF generation only - no UI changes)
    setTimeout(() => {
        if (isLandscape) {
            previewFrame.setAttribute('data-orientation', 'landscape');
        } else {
            previewFrame.setAttribute('data-orientation', 'portrait');
        }
        
        console.log(`‚úÖ Detected ${isLandscape ? 'landscape' : 'portrait'} orientation for PDF generation`);
    }, 200);
}

// Process template content by replacing placeholders with actual data
function processTemplateContent(templateHtml, placeholderData) {
    let processedHtml = templateHtml;
    
    // Replace participant name placeholder
    processedHtml = processedHtml.replace(/\{\{participant_name\}\}/g, placeholderData.participant_name || certificateData.participantName);
    
    // Replace department name placeholder  
    processedHtml = processedHtml.replace(/\{\{department_name\}\}/g, placeholderData.department_name || certificateData.department);
    
    // Replace team name placeholder (for team-based events)
    if (placeholderData.team_name || certificateData.teamName) {
        processedHtml = processedHtml.replace(/\{\{team_name\}\}/g, placeholderData.team_name || certificateData.teamName);
    }
    
    // Also handle alternative placeholder formats with spaces
    processedHtml = processedHtml.replace(/\{\{ participant_name \}\}/g, placeholderData.participant_name || certificateData.participantName);
    processedHtml = processedHtml.replace(/\{\{ department_name \}\}/g, placeholderData.department_name || certificateData.department);
    if (placeholderData.team_name || certificateData.teamName) {
        processedHtml = processedHtml.replace(/\{\{ team_name \}\}/g, placeholderData.team_name || certificateData.teamName);
    }
    
    // Extract any styles from the original template for separate handling
    const styleMatch = templateHtml.match(/<style[^>]*>([\s\S]*?)<\/style>/i);
    let extractedStyles = '';
    if (styleMatch) {
        extractedStyles = styleMatch[1];
        console.log('‚úÖ Extracted styles from template');
        console.log('üé® Style content:', extractedStyles.substring(0, 200) + '...');
    }
    
    // Extract only the body content if this is a complete HTML document
    const bodyMatch = processedHtml.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
    if (bodyMatch) {
        // Found body content, extract it
        processedHtml = bodyMatch[1];
        console.log('‚úÖ Extracted body content from complete HTML document');
    }
    
    // Remove any remaining <style> tags from the content to prevent text display
    processedHtml = processedHtml.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');
    
    // Store extracted styles separately for proper injection
    if (extractedStyles) {
        // Store styles in a data attribute or handle them separately
        processedHtml = `<div class="certificate-wrapper" data-styles="${encodeURIComponent(extractedStyles)}">${processedHtml}</div>`;
    }
    
    return processedHtml;
}

// Show status message with simple styling
function showStatus(message, type = 'info') {
    const statusEl = document.getElementById('status-message');
    statusEl.textContent = message;
    
    // Remove existing status classes
    statusEl.className = 'mt-4 p-3 rounded-lg text-center font-medium';
    
    // Add appropriate classes based on type
    switch(type) {
        case 'success':
            statusEl.classList.add('bg-green-50', 'text-green-800', 'border', 'border-green-200');
            break;
        case 'error':
            statusEl.classList.add('bg-red-50', 'text-red-800', 'border', 'border-red-200');
            break;
        case 'info':
        default:
            statusEl.classList.add('bg-blue-50', 'text-blue-800', 'border', 'border-blue-200');
            break;
    }
    
    statusEl.classList.remove('hidden');
}

// Hide status message
function hideStatus() {
    const statusEl = document.getElementById('status-message');
    statusEl.classList.add('hidden');
}

// Update button state with simple styling
function updateButtonState(isLoading, text) {
    const btn = document.getElementById('download-certificate-btn');
    btn.disabled = isLoading;
    
    if (isLoading) {
        btn.innerHTML = `<div class="loading-spinner"></div> ${text}`;
        btn.classList.remove('download-btn');
        btn.classList.add('cursor-not-allowed', 'opacity-75');
    } else {
        btn.innerHTML = `
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd"/>
            </svg>
            ${text}
        `;
        btn.classList.add('download-btn');
        btn.classList.remove('cursor-not-allowed', 'opacity-75');
    }
}

// Main certificate download function
async function downloadCertificate() {
    console.log('üöÄ Starting certificate download...');
    
    // Debug: Log certificate data
    console.log('üìä Certificate Data:', certificateData);
    
    // Debug: Check if template content exists
    const certificateContent = document.getElementById('certificate-content');
    console.log('üìÑ Certificate content exists:', !!certificateContent);
    console.log('üìÑ Certificate content HTML length:', certificateContent ? certificateContent.innerHTML.length : 0);
    
    if (certificateContent && certificateContent.innerHTML.length > 100) {
        console.log('üìÑ First 200 chars of certificate content:', certificateContent.innerHTML.substring(0, 200));
    }
    
    updateButtonState(true, 'Generating Certificate...');
    showStatus('Preparing certificate...', 'info');
    
    try {
        // Check if libraries are available
        if (!window.html2canvas || (!window.jsPDF && !window.PDFLib)) {
            throw new Error('Certificate libraries not loaded. Please refresh the page and try again.');
        }
          // Create certificate element for PDF generation
        const certificateElement = await createCertificateElement();
        
        // Determine orientation and canvas dimensions
        const isLandscape = certificateElement.style.width === '297mm';
        let canvasWidth, canvasHeight;
        
        if (isLandscape) {
            // A4 landscape: 297 √ó 210 mm at 96 DPI
            canvasWidth = Math.ceil(297 * 3.779527559);
            canvasHeight = Math.ceil(210 * 3.779527559);
        } else {
            // A4 portrait: 210 √ó 297 mm at 96 DPI
            canvasWidth = Math.ceil(210 * 3.779527559);
            canvasHeight = Math.ceil(297 * 3.779527559);
        }
        
        showStatus('Capturing certificate image...', 'info');
        
        // Debug: Log canvas dimensions and element info before capture
        console.log('üìê Canvas capture settings:', {
            element_width: certificateElement.offsetWidth,
            element_height: certificateElement.offsetHeight,
            canvas_width: canvasWidth,
            canvas_height: canvasHeight,
            orientation: isLandscape ? 'landscape' : 'portrait'
        });
        
        // Capture the certificate as canvas with optimized settings for certificate templates
        const canvas = await html2canvas(certificateElement, {
            scale: 2, // Higher quality
            backgroundColor: '#ffffff',
            logging: true, // Enable logging for debugging
            useCORS: true,
            allowTaint: false, // Don't allow tainted canvas
            foreignObjectRendering: false, // Disable for better compatibility
            removeContainer: true,
            width: canvasWidth,
            height: canvasHeight,
            windowWidth: canvasWidth,
            windowHeight: canvasHeight,
            onclone: function(clonedDoc) {
                console.log('üîç html2canvas cloned document:', clonedDoc);
                // Ensure images are visible in cloned document
                const clonedImages = clonedDoc.querySelectorAll('img');
                console.log(`üñºÔ∏è Found ${clonedImages.length} images in cloned document`);
                clonedImages.forEach((img, index) => {
                    console.log(`Image ${index + 1}: ${img.src} - Complete: ${img.complete} - Natural dimensions: ${img.naturalWidth}x${img.naturalHeight}`);
                });
            }
        });
        
        console.log('‚úÖ Canvas captured successfully:', {
            width: canvas.width,
            height: canvas.height,
            hasData: canvas.toDataURL().length > 1000
        });
        
        showStatus('Converting to PDF...', 'info');
          // Convert canvas to PDF and clean up
        await convertCanvasToPDF(canvas, certificateElement);
        
        showStatus('Certificate downloaded successfully!', 'success');
        
        // Send email notification (optional)
        try {
            await sendEmailNotification(canvas);
        } catch (emailError) {
            console.warn('Failed to send email notification:', emailError);
            // Don't fail the download if email fails
        }
        
        setTimeout(() => hideStatus(), 3000);
        
    } catch (error) {
        console.error('Certificate download failed:', error);
        showStatus(`Download failed: ${error.message}`, 'error');
    } finally {
        updateButtonState(false, 'Download Certificate (PDF)');
    }
}

// Convert image to base64 data URL for better compatibility with html2canvas
async function convertImageToBase64(img) {
    return new Promise((resolve) => {
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = img.naturalWidth || img.width;
            canvas.height = img.naturalHeight || img.height;
            
            ctx.drawImage(img, 0, 0);
            
            const dataURL = canvas.toDataURL('image/png');
            console.log(`üîÑ Converted image to base64: ${img.src} -> ${dataURL.substring(0, 50)}...`);
            resolve(dataURL);
        } catch (error) {
            console.warn(`‚ùå Failed to convert image to base64: ${error.message}`);
            resolve(img.src); // Fallback to original src
        }
    });
}

// Create certificate element for PDF generation
async function createCertificateElement() {
    // Get the certificate content element
    const certificateContent = document.getElementById('certificate-content');
    if (!certificateContent || !certificateContent.innerHTML.trim()) {
        throw new Error('Certificate template not loaded');
    }
    
    console.log('üéØ Creating certificate element for PDF...');
    console.log('üìÑ Certificate content HTML length:', certificateContent.innerHTML.length);
    
    // Get the actual certificate content (look for wrapper first)
    const certificateWrapper = certificateContent.querySelector('.certificate-wrapper');
    const actualContent = certificateWrapper || certificateContent.firstElementChild;
    
    if (!actualContent || actualContent.classList.contains('certificate-loading')) {
        throw new Error('Certificate content not ready - still loading');
    }
    
    // Clone the actual content directly
    const clonedElement = actualContent.cloneNode(true);
    
    // Ensure cloned element is properly styled for rendering
    clonedElement.style.display = 'block';
    clonedElement.style.visibility = 'visible';
    clonedElement.style.position = 'static';
    
    // Handle extracted styles for PDF generation
    let stylesForPdf = '';
    if (clonedElement.hasAttribute('data-styles')) {
        const encodedStyles = clonedElement.getAttribute('data-styles');
        if (encodedStyles) {
            stylesForPdf = decodeURIComponent(encodedStyles);
            console.log('üé® Retrieved styles for PDF generation');
        }
    }
    
    // Determine orientation from data attribute (not CSS class)
    const previewFrame = document.getElementById('certificate-preview-frame');
    const isLandscape = previewFrame.getAttribute('data-orientation') === 'landscape';
    console.log(`üìê Using ${isLandscape ? 'landscape' : 'portrait'} orientation for PDF`);
      // Create a wrapper container for proper sizing
    const wrapperDiv = document.createElement('div');
    
    // Include styles in the wrapper if available
    if (stylesForPdf) {
        const styleElement = document.createElement('style');
        styleElement.textContent = stylesForPdf;
        wrapperDiv.appendChild(styleElement);
        console.log('üé® Added certificate styles to PDF wrapper');
    }
    
    wrapperDiv.appendChild(clonedElement);
    
    // Apply specific styling for PDF generation based on orientation
    wrapperDiv.style.position = 'absolute';
    wrapperDiv.style.left = '-9999px';
    wrapperDiv.style.top = '0';
    wrapperDiv.style.backgroundColor = '#ffffff';
    wrapperDiv.style.fontFamily = 'Arial, sans-serif';
    wrapperDiv.style.overflow = 'visible';
    wrapperDiv.style.zoom = '1';
    wrapperDiv.style.transform = 'none'; // Remove any scaling
    
    if (isLandscape) {
        // A4 landscape: 297 √ó 210 mm
        wrapperDiv.style.width = '297mm';
        wrapperDiv.style.height = '210mm';
    } else {
        // A4 portrait: 210 √ó 297 mm
        wrapperDiv.style.width = '210mm';
        wrapperDiv.style.height = '297mm';
    }
    
    // Ensure the cloned content fills the wrapper
    clonedElement.style.width = '100%';
    clonedElement.style.height = '100%';
    clonedElement.style.margin = '0';
    clonedElement.style.padding = '0';
    clonedElement.style.transform = 'none'; // Remove any preview scaling
    clonedElement.style.overflow = 'visible';
    
    // Fix image paths to use absolute URLs
    const images = wrapperDiv.querySelectorAll('img');
    const imageLoadPromises = Array.from(images).map(async (img) => {
        return new Promise(async (resolve) => {
            try {
                // Convert relative paths to absolute URLs
                if (img.src.includes('../../../static/')) {
                    const newSrc = img.src.replace('../../../static/', '/static/');
                    console.log(`üñºÔ∏è Converting image path: ${img.src} -> ${newSrc}`);
                    img.src = newSrc;
                }
                
                // Wait for image to load or convert to base64
                if (img.complete && img.naturalWidth > 0) {
                    console.log(`‚úÖ Image already loaded: ${img.src}`);
                    // Convert to base64 for better compatibility
                    const base64Src = await convertImageToBase64(img);
                    img.src = base64Src;
                    resolve();
                } else {
                    img.onload = async () => {
                        console.log(`‚úÖ Image loaded successfully: ${img.src}`);
                        // Convert to base64 for better compatibility
                        const base64Src = await convertImageToBase64(img);
                        img.src = base64Src;
                        resolve();
                    };
                    img.onerror = () => {
                        console.warn(`‚ùå Image failed to load: ${img.src}`);
                        // Hide failed images instead of showing broken image icon
                        img.style.display = 'none';
                        resolve();
                    };
                    
                    // Set a timeout to prevent hanging
                    setTimeout(() => {
                        console.warn(`‚è∞ Image load timeout: ${img.src}`);
                        img.style.display = 'none';
                        resolve();
                    }, 5000);
                }
            } catch (error) {
                console.warn(`‚ùå Image processing error: ${error.message}`);
                img.style.display = 'none';
                resolve();
            }
        });
    });
    
    // Append to body temporarily
    document.body.appendChild(wrapperDiv);
    
    console.log('üìã Created PDF element dimensions:', {
        width: wrapperDiv.style.width,
        height: wrapperDiv.style.height,
        orientation: isLandscape ? 'landscape' : 'portrait',
        content_html_length: clonedElement.innerHTML.length
    });
    
    // Wait for all images to load
    console.log(`‚è≥ Waiting for ${images.length} images to load...`);
    await Promise.all(imageLoadPromises);
    
    // Extra time for fonts and rendering
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    console.log('‚úÖ Certificate element ready for capture');
    return wrapperDiv;
}

// Convert canvas to PDF and download
async function convertCanvasToPDF(canvas, certificateElement) {
    const imgData = canvas.toDataURL('image/png', 1.0);
    
    // Clean up temporary element if provided
    if (certificateElement && certificateElement.parentNode) {
        certificateElement.parentNode.removeChild(certificateElement);
    }
    
    // Try jsPDF first
    if (window.jsPDF) {
        try {
            const { jsPDF } = window.jsPDF;
            const pdf = new jsPDF({
                orientation: 'landscape',
                unit: 'px',
                format: [canvas.width, canvas.height]
            });
            
            pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
            
            const fileName = `certificate_${certificateData.participantName.replace(/[^a-zA-Z0-9]/g, '_')}_${certificateData.eventName.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`;
            pdf.save(fileName);
            console.log('‚úÖ PDF downloaded successfully using jsPDF');
            return;
        } catch (jsPDFError) {
            console.warn('jsPDF failed, trying alternative method:', jsPDFError);
        }
    }
    
    // Fallback: Try PDF-lib
    if (window.PDFLib) {
        try {
            const { PDFDocument } = window.PDFLib;
            const pdfDoc = await PDFDocument.create();
            
            // Add page with canvas dimensions
            const page = pdfDoc.addPage([canvas.width, canvas.height]);
            
            // Convert canvas to PNG bytes
            const pngImageBytes = await fetch(imgData).then(res => res.arrayBuffer());
            const pngImage = await pdfDoc.embedPng(pngImageBytes);
            
            // Draw the image
            page.drawImage(pngImage, {
                x: 0,
                y: 0,
                width: canvas.width,
                height: canvas.height,
            });
            
            // Save the PDF
            const pdfBytes = await pdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            
            const fileName = `certificate_${certificateData.participantName.replace(/[^a-zA-Z0-9]/g, '_')}_${certificateData.eventName.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`;
            
            // Download the file
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            link.click();
            
            // Clean up
            URL.revokeObjectURL(link.href);
            console.log('‚úÖ PDF downloaded successfully using PDF-lib');
            return;
        } catch (pdfLibError) {
            console.warn('PDF-lib failed:', pdfLibError);
        }
    }
    
    // Final fallback: Just download the image
    const link = document.createElement('a');
    link.href = imgData;
    link.download = `certificate_${certificateData.participantName.replace(/[^a-zA-Z0-9]/g, '_')}_${certificateData.eventName.replace(/[^a-zA-Z0-9]/g, '_')}.png`;
    link.click();
    
    console.warn('PDF libraries not working, downloaded as PNG instead');
}

// Send email notification (only once per student per event)
async function sendEmailNotification(canvas) {
    try {
        console.log('üîî Attempting to send certificate email notification...');
        
        // Create proper PDF data for email
        let pdfBase64Data = null;
        const fileName = `certificate_${certificateData.participantName.replace(/[^a-zA-Z0-9]/g, '_')}_${certificateData.eventName.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`;
        
        // Try to create PDF using jsPDF first
        if (window.jsPDF) {
            try {
                const imgData = canvas.toDataURL('image/png', 1.0);
                const { jsPDF } = window.jsPDF;
                const pdf = new jsPDF({
                    orientation: 'landscape',
                    unit: 'px',
                    format: [canvas.width, canvas.height]
                });
                
                pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
                  // Get PDF as base64 string
                const pdfOutput = pdf.output('datauristring'); // Returns "data:application/pdf;base64,..."
                pdfBase64Data = pdfOutput.split(',')[1]; // Remove the data URI prefix
                console.log('‚úÖ Created PDF using jsPDF for email:', {
                    size: pdfBase64Data.length,
                    prefix: pdfOutput.substring(0, 50) + '...'
                });
            } catch (jsPDFError) {
                console.warn('jsPDF failed for email, trying PDF-lib:', jsPDFError);
            }
        }
        
        // Fallback: Try PDF-lib if jsPDF failed
        if (!pdfBase64Data && window.PDFLib) {
            try {
                const imgData = canvas.toDataURL('image/png', 1.0);
                const { PDFDocument } = window.PDFLib;
                const pdfDoc = await PDFDocument.create();
                
                // Add page with canvas dimensions
                const page = pdfDoc.addPage([canvas.width, canvas.height]);
                
                // Convert canvas to PNG bytes
                const pngImageBytes = await fetch(imgData).then(res => res.arrayBuffer());
                const pngImage = await pdfDoc.embedPng(pngImageBytes);
                
                // Draw the image
                page.drawImage(pngImage, {
                    x: 0,
                    y: 0,
                    width: canvas.width,
                    height: canvas.height,
                });
                  // Get PDF bytes and convert to base64
                const pdfBytes = await pdfDoc.save();
                pdfBase64Data = btoa(String.fromCharCode(...new Uint8Array(pdfBytes)));
                console.log('‚úÖ Created PDF using PDF-lib for email:', {
                    size: pdfBase64Data.length,
                    bytes: pdfBytes.length
                });
            } catch (pdfLibError) {
                console.warn('PDF-lib failed for email:', pdfLibError);
            }
        }
        
        // If no PDF library worked, skip email
        if (!pdfBase64Data) {
            console.warn('üìß Could not create PDF for email - PDF libraries not available');
            showStatus('Certificate downloaded! (Email requires PDF libraries)', 'success');
            return;
        }
        
        const response = await fetch('/client/api/send-certificate-email', {
            method: 'POST',
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                event_id: certificateData.eventId,
                enrollment_no: certificateData.enrollmentNo,
                pdf_base64: pdfBase64Data, // Now sending actual PDF data
                file_name: fileName
            })
        });
        
        if (response.status === 404) {
            console.warn('üìß Email API endpoint not found (404). Email feature may be disabled.');
            return;
        }
        
        const result = await response.json();        if (result.success) {
            console.log('‚úÖ Certificate email queued successfully');
            if (result.message && result.message.includes('already sent')) {
                showStatus('Certificate downloaded! (Email was already sent previously)', 'success');
            } else if (result.message && result.message.includes('queued')) {
                showStatus('Certificate downloaded! Email is being sent in the background.', 'success');
            } else {
                showStatus('Certificate downloaded and email sent to your inbox!', 'success');
            }
        } else {
            console.log('üìß Email notification status:', result.message);
            // Handle different email scenarios with appropriate messaging
            if (result.message && result.message.includes('already sent')) {
                console.log('üìß Email already sent for this event - showing download success only');
                showStatus('Certificate downloaded successfully! (Email was already sent)', 'success');
            } else {
                console.warn('üìß Email notification failed:', result.message);
                showStatus('Certificate downloaded! (Email notification failed)', 'success');
            }
        }
    } catch (error) {
        console.warn('üìß Failed to send email notification:', error);
        showStatus('Certificate downloaded! (Email notification unavailable)', 'success');
    }
}

// Add debug function to window for testing
window.debugCertificate = function() {
    console.log('=== CERTIFICATE DEBUG ===');
    console.log('Certificate Data:', certificateData);
    
    const content = document.getElementById('certificate-content');
    console.log('Content Element:', content);
    console.log('Content HTML length:', content ? content.innerHTML.length : 0);
    if (content && content.innerHTML.length > 0) {
        console.log('First 300 chars:', content.innerHTML.substring(0, 300));
    }
    
    const preview = document.getElementById('certificate-preview');
    console.log('Preview Element:', preview);
    console.log('Preview dimensions:', preview ? {
        width: preview.offsetWidth,
        height: preview.offsetHeight,
        visible: preview.offsetParent !== null
    } : 'NOT FOUND');
    
    console.log('=== END DEBUG ===');
};

// Clean up function to remove temporary elements
function cleanupTempElements() {
    const tempElements = document.querySelectorAll('[style*="-9999px"]');
    tempElements.forEach(el => el.remove());
}

// Clean up on page unload
window.addEventListener('beforeunload', cleanupTempElements);

// Removed resize handler for scaling since we preserve original template size
// The certificate will maintain its original dimensions regardless of window size

// Modal functions for certificate preview
function openPreviewModal() {
    console.log('üîç Opening certificate preview modal as floating iframe');
    
    // Check if certificate content is loaded
    const certificateContent = document.getElementById('certificate-content');
    if (!certificateContent || !certificateContent.innerHTML.trim() || certificateContent.innerHTML.includes('Loading certificate template')) {
        showStatus('Certificate is still loading. Please wait...', 'info');
        return;
    }
    
    // Get the actual certificate content (skip loading elements)
    const certificateWrapper = certificateContent.querySelector('.certificate-wrapper');
    const actualContent = certificateWrapper || certificateContent.firstElementChild;
    
    if (!actualContent || actualContent.classList.contains('certificate-loading')) {
        showStatus('Certificate content not ready. Please wait...', 'info');
        return;
    }
    
    // Get modal container
    const modalContent = document.getElementById('modal-certificate-content');
    const loadingPlaceholder = document.getElementById('modal-loading-placeholder');
    
    // Create a clean copy of the certificate content
    const contentClone = actualContent.cloneNode(true);
    
    // Remove any wrapper styling to make it pure certificate content
    contentClone.style.position = 'static';
    contentClone.style.transform = 'none';
    contentClone.style.margin = '0';
    contentClone.style.padding = '0';
    contentClone.style.display = 'block';
    contentClone.style.visibility = 'visible';
    contentClone.style.borderRadius = '8px';
    contentClone.style.overflow = 'hidden';
    contentClone.style.backgroundColor = '#ffffff';
    
    // Apply certificate styles if available
    if (contentClone.hasAttribute('data-styles')) {
        const encodedStyles = contentClone.getAttribute('data-styles');
        if (encodedStyles) {
            const styles = decodeURIComponent(encodedStyles);
            
            // Create a style element specifically for the modal
            const modalStyleElement = document.createElement('style');
            modalStyleElement.id = 'modal-certificate-styles';
            modalStyleElement.textContent = styles;
            
            // Remove any existing modal certificate styles
            const existingModalStyles = document.getElementById('modal-certificate-styles');
            if (existingModalStyles) {
                existingModalStyles.remove();
            }
            
            // Inject styles for modal
            document.head.appendChild(modalStyleElement);
            console.log('‚úÖ Applied certificate styles to modal');
        }
    }
    
    // Replace loading placeholder with actual certificate content
    if (loadingPlaceholder) {
        modalContent.removeChild(loadingPlaceholder);
    }
    
    // Clear any existing content and add certificate as the main content
    const existingCertificate = modalContent.querySelector('div:not(button)');
    if (existingCertificate) {
        modalContent.removeChild(existingCertificate);
    }
    
    modalContent.appendChild(contentClone);
    
    // Show the modal
    const modal = document.getElementById('certificate-preview-modal');
    modal.classList.remove('hidden');
    
    // Prevent body scroll
    document.body.style.overflow = 'hidden';
    
    // Auto-scale certificate to fit viewport as floating iframe
    setTimeout(() => {
        scaleFloatingCertificate();
    }, 100);
    
    console.log('‚úÖ Certificate preview modal opened as floating iframe');
}

function closePreviewModal() {
    console.log('‚ùå Closing certificate preview modal');
    
    // Hide the modal
    const modal = document.getElementById('certificate-preview-modal');
    modal.classList.add('hidden');
    
    // Reset modal content transform
    const modalContent = document.getElementById('modal-certificate-content');
    modalContent.style.transform = 'none';
    
    // Restore loading placeholder for next use
    const existingCertificate = modalContent.querySelector('div:not(button)');
    if (existingCertificate) {
        modalContent.removeChild(existingCertificate);
    }
    
    // Add back loading placeholder
    const loadingPlaceholder = document.createElement('div');
    loadingPlaceholder.id = 'modal-loading-placeholder';
    loadingPlaceholder.className = 'w-96 h-64 flex justify-center items-center text-gray-500 bg-white rounded-lg';
    loadingPlaceholder.innerHTML = `
        <div class="text-center p-8">
            <svg class="w-12 h-12 mx-auto mb-4 text-gray-300" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd"/>
            </svg>
            <p class="text-lg font-medium">Loading certificate preview...</p>
        </div>
    `;
    modalContent.appendChild(loadingPlaceholder);
    
    // Clean up modal-specific styles
    const modalStyles = document.getElementById('modal-certificate-styles');
    if (modalStyles) {
        modalStyles.remove();
    }
    
    // Restore body scroll
    document.body.style.overflow = '';
    
    console.log('‚úÖ Certificate preview modal closed and reset');
}

// Close modal when clicking outside
document.addEventListener('click', function(event) {
    const modal = document.getElementById('certificate-preview-modal');
    if (event.target === modal) {
        closePreviewModal();
    }
});

// Close modal with Escape key
document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
        const modal = document.getElementById('certificate-preview-modal');
        if (!modal.classList.contains('hidden')) {
            closePreviewModal();
        }
    }
});

// Scale certificate as floating iframe to fit viewport optimally
function scaleFloatingCertificate() {
    const modalContent = document.getElementById('modal-certificate-content');
    const certificateElement = modalContent.querySelector('div:not(button)');
    
    if (!modalContent || !certificateElement) {
        console.warn('Modal content or certificate element not found for floating scaling');
        return;
    }
    
    // Reset any existing transform to get natural dimensions
    modalContent.style.transform = 'none';
    certificateElement.style.transform = 'none';
    
    // Wait for render and then calculate optimal scale
    setTimeout(() => {
        const certificateRect = certificateElement.getBoundingClientRect();
        const certificateWidth = certificateRect.width;
        const certificateHeight = certificateRect.height;
        
        // Get viewport dimensions with safe padding
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const safeWidth = viewportWidth - 80; // 40px padding each side
        const safeHeight = viewportHeight - 80; // 40px padding top/bottom
        
        if (certificateWidth > 0 && certificateHeight > 0) {
            // Calculate scale to fit in viewport while maintaining aspect ratio
            const scaleX = safeWidth / certificateWidth;
            const scaleY = safeHeight / certificateHeight;
            const scale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down
            
            if (scale < 1) {
                modalContent.style.transform = `scale(${scale})`;
                console.log(`üìè Scaled floating certificate by ${scale.toFixed(3)} to fit viewport`);
            } else {
                console.log('üìè Certificate fits naturally in viewport as floating iframe');
            }
            
            // Log final dimensions for debugging
            console.log('üìê Certificate floating dimensions:', {
                original: { width: certificateWidth, height: certificateHeight },
                viewport_safe: { width: safeWidth, height: safeHeight },
                scale: scale.toFixed(3)
            });
        } else {
            console.warn('Could not get valid certificate dimensions for floating scaling');
        }
    }, 50);
}

// Handle window resize for floating certificate scaling
window.addEventListener('resize', function() {
    const modal = document.getElementById('certificate-preview-modal');
    if (!modal.classList.contains('hidden')) {
        clearTimeout(window.modalResizeTimeout);
        window.modalResizeTimeout = setTimeout(() => {
            scaleFloatingCertificate();
        }, 250);
    }
});
</script>
{% endif %}
{% endblock %}
