CAMPUSCONNECT COMPLETE EVENT LIFECYCLE IMPLEMENTATION PLAN
=========================================================
Date: August 16, 2025
Scope: Complete lifecycle with role-based dashboards and automated cleanup

==============================================================================
IMPLEMENTATION OVERVIEW
==============================================================================

GOAL: Complete the event lifecycle implementation while maintaining event_lifecycle.txt compliance

APPROACH: 
- Keep existing dynamic attendance system (it's excellent)
- Add missing role-based dashboards
- Implement automated event completion workflow
- Add proper data cleanup automation
- Maintain simplicity and performance

ESTIMATED TIME: 3 weeks
COMPLEXITY: Medium (building on existing solid foundation)

==============================================================================
PHASE 1: DATABASE OPTIMIZATION (Week 1, Days 1-2)
==============================================================================

1.1 COLLECTION MIGRATION AND INDEXING
=====================================

TASK: Rename and optimize collection to match event_lifecycle.txt

```javascript
// MongoDB Migration Script
// Rename collection
db.student_event_participations.renameCollection("student_registrations");

// Create required indexes per event_lifecycle.txt
db.student_registrations.createIndex({"student.enrollment_no": 1});
db.student_registrations.createIndex({"event.event_id": 1});
db.student_registrations.createIndex({"registration.registered_at": -1});
db.student_registrations.createIndex(
  {"student.enrollment_no": 1, "event.event_id": 1}, 
  {unique: true}
);

// Additional indexes for dashboard performance
db.student_registrations.createIndex({"registration.status": 1});
db.student_registrations.createIndex({"attendance.marked": 1});
db.student_registrations.createIndex({"certificate.eligible": 1});
```

1.2 UPDATE SERVICE LAYER
========================

File: `backend/services/participation_service.py`

```python
class StudentEventParticipationService:
    def __init__(self):
        # Update collection name to match event_lifecycle.txt
        self.collection = "student_registrations"  # Changed from student_event_participations
        self.events_collection = "events"
        self.students_collection = "students"
```

1.3 CREATE ANALYTICS COLLECTIONS
================================

```python
# New collections for efficient analytics
ANALYTICS_COLLECTIONS = {
    "event_statistics": {
        # Real-time event stats for organizer dashboard
        "_id": "event_id",
        "total_registered": 0,
        "individual_count": 0,
        "team_count": 0,
        "attendance_count": 0,
        "feedback_count": 0,
        "certificate_eligible": 0,
        "last_updated": "datetime"
    },
    
    "certificate_batches": {
        # Bulk certificate generation tracking
        "_id": "batch_id",
        "event_id": "string",
        "generated_at": "datetime",
        "eligible_students": ["array"],
        "generated_certificates": ["array"],
        "status": "pending/completed/failed"
    }
}
```

==============================================================================
PHASE 2: STUDENT DASHBOARD APIs (Week 1, Days 3-5)
==============================================================================

2.1 STUDENT PARTICIPATION OVERVIEW API
======================================

File: `backend/api/v1/student_dashboard.py`

```python
@router.get("/dashboard")
async def get_student_dashboard(
    current_user = Depends(get_current_student)
):
    """Complete student participation dashboard"""
    enrollment_no = current_user["enrollment_no"]
    
    # Get all registrations
    registrations = await DatabaseOperations.find_many(
        "student_registrations",
        {"student.enrollment_no": enrollment_no},
        sort_by=[("registration.registered_at", -1)]
    )
    
    dashboard_data = {
        "student_info": {
            "enrollment_no": enrollment_no,
            "name": current_user["full_name"],
            "department": current_user["department"]
        },
        "current_registrations": [],
        "attendance_summary": {},
        "certificates_available": [],
        "participation_stats": {
            "total_events": 0,
            "completed_events": 0,
            "certificates_earned": 0,
            "average_attendance": 0
        }
    }
    
    for registration in registrations:
        event_id = registration["event"]["event_id"]
        
        # Get attendance status
        attendance_status = await get_attendance_status(enrollment_no, event_id)
        
        # Build registration summary
        reg_summary = {
            "registration_id": registration["registration_id"],
            "event": registration["event"],
            "registration_type": registration["registration"]["type"],
            "status": registration["registration"]["status"],
            "attendance": {
                "percentage": attendance_status.get("overall_percentage", 0),
                "status": attendance_status.get("final_status", "pending"),
                "sessions_attended": len(attendance_status.get("sessions_attended", [])),
                "total_sessions": len(attendance_status.get("sessions", []))
            },
            "feedback": registration["feedback"],
            "certificate": registration["certificate"]
        }
        
        dashboard_data["current_registrations"].append(reg_summary)
    
    return dashboard_data

@router.get("/attendance-status/{event_id}")
async def get_detailed_attendance_status(
    event_id: str,
    current_user = Depends(get_current_student)
):
    """Detailed attendance status for a specific event"""
    enrollment_no = current_user["enrollment_no"]
    
    # Use existing dynamic attendance service
    attendance_service = IntegratedDynamicAttendanceService()
    return await attendance_service.get_student_attendance_dashboard(
        event_id, enrollment_no
    )

@router.get("/certificates")
async def get_available_certificates(
    current_user = Depends(get_current_student)
):
    """Get all available certificates for download"""
    enrollment_no = current_user["enrollment_no"]
    
    certificates = await DatabaseOperations.find_many(
        "student_registrations",
        {
            "student.enrollment_no": enrollment_no,
            "certificate.issued": True
        },
        projection={
            "event.event_name": 1,
            "certificate": 1,
            "registration.registered_at": 1
        }
    )
    
    return {
        "certificates": [
            {
                "certificate_id": cert["certificate"]["certificate_id"],
                "event_name": cert["event"]["event_name"],
                "issued_at": cert["certificate"]["issued_at"],
                "download_url": f"/api/v1/certificates/{cert['certificate']['certificate_id']}/download"
            }
            for cert in certificates
        ]
    }
```

2.2 REAL-TIME STUDENT UPDATES
=============================

```python
@router.get("/real-time-status/{event_id}")
async def get_real_time_status(
    event_id: str,
    current_user = Depends(get_current_student)
):
    """Real-time event status for student"""
    enrollment_no = current_user["enrollment_no"]
    
    # Get current registration
    registration = await DatabaseOperations.find_one(
        "student_registrations",
        {
            "student.enrollment_no": enrollment_no,
            "event.event_id": event_id
        }
    )
    
    if not registration:
        raise HTTPException(status_code=404, detail="Registration not found")
    
    # Get active attendance sessions
    attendance_service = IntegratedDynamicAttendanceService()
    active_sessions = await attendance_service.get_active_attendance_sessions(event_id)
    
    return {
        "registration_status": registration["registration"]["status"],
        "attendance_status": registration["attendance"],
        "active_sessions": active_sessions.get("active_sessions", []),
        "upcoming_sessions": active_sessions.get("upcoming_sessions", []),
        "can_mark_attendance": active_sessions.get("can_mark_attendance", False),
        "feedback_pending": not registration["feedback"]["submitted"],
        "certificate_eligible": registration["certificate"]["eligible"]
    }
```

==============================================================================
PHASE 3: ORGANIZER DASHBOARD APIs (Week 2, Days 1-3)
==============================================================================

3.1 ORGANIZER EVENT OVERVIEW API
================================

File: `backend/api/v1/organizer_dashboard.py`

```python
@router.get("/events/{event_id}/overview")
async def get_event_overview(
    event_id: str,
    current_user = Depends(get_current_organizer)
):
    """Complete event overview for organizers"""
    
    # Verify organizer has access to this event
    event = await verify_organizer_access(current_user, event_id)
    
    # Get real-time statistics
    stats = await get_event_real_time_stats(event_id)
    
    # Get attendance analytics
    attendance_service = IntegratedDynamicAttendanceService()
    attendance_analytics = await attendance_service.get_event_attendance_analytics(event_id)
    
    return {
        "event_info": {
            "event_id": event["event_id"],
            "event_name": event["event_name"],
            "event_type": event["event_type"],
            "dates": {
                "start": event["start_datetime"],
                "end": event["end_datetime"]
            },
            "status": event.get("status", "active")
        },
        "registration_stats": {
            "total_registered": stats["total_registered"],
            "individual_registrations": stats["individual_count"],
            "team_registrations": stats["team_count"],
            "registration_trend": stats["registration_trend"]
        },
        "attendance_stats": attendance_analytics,
        "feedback_stats": {
            "total_feedback": stats["feedback_count"],
            "feedback_rate": (stats["feedback_count"] / stats["total_registered"] * 100) if stats["total_registered"] > 0 else 0,
            "average_rating": stats.get("average_rating", 0)
        },
        "certificate_stats": {
            "eligible_count": stats["certificate_eligible"],
            "issued_count": stats["certificate_issued"],
            "pending_count": stats["certificate_eligible"] - stats["certificate_issued"]
        }
    }

@router.get("/events/{event_id}/registrations")
async def get_event_registrations(
    event_id: str,
    limit: int = Query(50, ge=1, le=200),
    skip: int = Query(0, ge=0),
    filter_type: Optional[str] = Query(None),
    current_user = Depends(get_current_organizer)
):
    """Get paginated list of event registrations"""
    
    await verify_organizer_access(current_user, event_id)
    
    # Build filter query
    query = {"event.event_id": event_id}
    if filter_type:
        query["registration.type"] = filter_type
    
    # Get registrations with pagination
    registrations = await DatabaseOperations.find_many(
        "student_registrations",
        query,
        limit=limit,
        skip=skip,
        sort_by=[("registration.registered_at", -1)]
    )
    
    # Enhance with attendance data
    enhanced_registrations = []
    for reg in registrations:
        enrollment_no = reg["student"]["enrollment_no"]
        
        # Get attendance status
        attendance_record = await DatabaseOperations.find_one(
            "student_attendance_records",
            {
                "student_enrollment": enrollment_no,
                "event_id": event_id
            }
        )
        
        attendance_info = {
            "percentage": attendance_record.get("overall_percentage", 0) if attendance_record else 0,
            "status": attendance_record.get("final_status", "pending") if attendance_record else "pending",
            "sessions_attended": len(attendance_record.get("sessions_attended", {})) if attendance_record else 0
        }
        
        enhanced_registrations.append({
            "registration_id": reg["registration_id"],
            "student": reg["student"],
            "registration": reg["registration"],
            "team": reg.get("team"),
            "attendance": attendance_info,
            "feedback": reg["feedback"],
            "certificate": reg["certificate"]
        })
    
    # Get total count for pagination
    total_count = await DatabaseOperations.count_documents("student_registrations", query)
    
    return {
        "registrations": enhanced_registrations,
        "pagination": {
            "total": total_count,
            "limit": limit,
            "skip": skip,
            "has_more": (skip + limit) < total_count
        }
    }

@router.get("/events/{event_id}/attendance-monitor")
async def get_real_time_attendance_monitor(
    event_id: str,
    current_user = Depends(get_current_organizer)
):
    """Real-time attendance monitoring for organizers"""
    
    await verify_organizer_access(current_user, event_id)
    
    # Get current active sessions
    attendance_service = IntegratedDynamicAttendanceService()
    active_sessions = await attendance_service.get_active_attendance_sessions(event_id)
    
    # Get recent attendance marks (last 30 minutes)
    recent_cutoff = datetime.utcnow() - timedelta(minutes=30)
    recent_attendance = await DatabaseOperations.find_many(
        "student_attendance_records",
        {
            "event_id": event_id,
            "calculated_at": {"$gte": recent_cutoff}
        },
        sort_by=[("calculated_at", -1)],
        limit=20
    )
    
    return {
        "active_sessions": active_sessions.get("active_sessions", []),
        "recent_attendance": [
            {
                "student_enrollment": record["student_enrollment"],
                "sessions_attended": len(record.get("sessions_attended", {})),
                "overall_percentage": record.get("overall_percentage", 0),
                "status": record.get("final_status", "pending"),
                "last_updated": record.get("calculated_at")
            }
            for record in recent_attendance
        ],
        "live_stats": {
            "total_online": len(recent_attendance),
            "attendance_rate": await calculate_current_attendance_rate(event_id)
        }
    }
```

3.2 FEEDBACK MANAGEMENT API
===========================

```python
@router.get("/events/{event_id}/feedback-summary")
async def get_feedback_summary(
    event_id: str,
    current_user = Depends(get_current_organizer)
):
    """Get comprehensive feedback summary"""
    
    await verify_organizer_access(current_user, event_id)
    
    # Aggregate feedback data
    feedback_pipeline = [
        {"$match": {"event.event_id": event_id, "feedback.submitted": True}},
        {"$group": {
            "_id": None,
            "total_feedback": {"$sum": 1},
            "average_rating": {"$avg": "$feedback.rating"},
            "rating_distribution": {
                "$push": "$feedback.rating"
            },
            "all_comments": {
                "$push": "$feedback.comments"
            }
        }}
    ]
    
    feedback_stats = await DatabaseOperations.aggregate(
        "student_registrations", feedback_pipeline
    )
    
    if not feedback_stats:
        return {"message": "No feedback submitted yet"}
    
    stats = feedback_stats[0]
    
    # Calculate rating distribution
    rating_dist = {}
    for rating in stats["rating_distribution"]:
        rating_dist[str(rating)] = rating_dist.get(str(rating), 0) + 1
    
    # Extract common themes from comments (simple keyword analysis)
    all_comments = [comment for comment in stats["all_comments"] if comment]
    common_words = extract_common_themes(all_comments)
    
    return {
        "total_feedback": stats["total_feedback"],
        "average_rating": round(stats["average_rating"], 2),
        "rating_distribution": rating_dist,
        "common_themes": common_words[:10],  # Top 10 common words
        "recent_comments": all_comments[-5:] if all_comments else []  # Last 5 comments
    }
```

==============================================================================
PHASE 4: EVENT COMPLETION WORKFLOW (Week 2, Days 4-5)
==============================================================================

4.1 EVENT COMPLETION API
========================

```python
@router.post("/events/{event_id}/complete")
async def complete_event(
    event_id: str,
    completion_data: EventCompletionRequest,
    current_user = Depends(get_current_organizer)
):
    """Complete event and trigger cleanup workflow"""
    
    await verify_organizer_access(current_user, event_id)
    
    try:
        # Step 1: Validate event can be completed
        validation_result = await validate_event_completion(event_id)
        if not validation_result["can_complete"]:
            raise HTTPException(
                status_code=400, 
                detail=f"Cannot complete event: {validation_result['reason']}"
            )
        
        # Step 2: Freeze attendance tracking
        await freeze_attendance_tracking(event_id)
        
        # Step 3: Calculate final attendance statistics
        final_stats = await calculate_final_event_statistics(event_id)
        
        # Step 4: Determine certificate eligibility
        await determine_certificate_eligibility(event_id)
        
        # Step 5: Generate certificates if requested
        if completion_data.generate_certificates:
            certificate_batch = await generate_event_certificates(event_id)
            
        # Step 6: Update event status
        await DatabaseOperations.update_one(
            "events",
            {"event_id": event_id},
            {
                "$set": {
                    "status": "completed",
                    "completed_at": datetime.utcnow(),
                    "completed_by": current_user["user_id"],
                    "final_statistics": final_stats
                }
            }
        )
        
        # Step 7: Schedule cleanup job
        await schedule_event_cleanup(event_id, completion_data.cleanup_delay_days)
        
        return {
            "success": True,
            "message": "Event completed successfully",
            "final_statistics": final_stats,
            "certificate_batch_id": certificate_batch.get("batch_id") if completion_data.generate_certificates else None,
            "cleanup_scheduled": True
        }
        
    except Exception as e:
        logger.error(f"Error completing event {event_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to complete event")

async def determine_certificate_eligibility(event_id: str):
    """Determine which students are eligible for certificates"""
    
    # Get all registrations for the event
    registrations = await DatabaseOperations.find_many(
        "student_registrations",
        {"event.event_id": event_id}
    )
    
    for registration in registrations:
        enrollment_no = registration["student"]["enrollment_no"]
        
        # Get final attendance status
        attendance_record = await DatabaseOperations.find_one(
            "student_attendance_records",
            {
                "student_enrollment": enrollment_no,
                "event_id": event_id
            }
        )
        
        # Determine eligibility based on attendance
        is_eligible = False
        if attendance_record:
            final_status = attendance_record.get("final_status", "absent")
            is_eligible = final_status in ["present", "partial"] and attendance_record.get("overall_percentage", 0) >= 75
        
        # Update registration with eligibility
        await DatabaseOperations.update_one(
            "student_registrations",
            {"_id": registration["_id"]},
            {
                "$set": {
                    "certificate.eligible": is_eligible,
                    "certificate.eligibility_calculated_at": datetime.utcnow()
                }
            }
        )

async def generate_event_certificates(event_id: str) -> Dict[str, Any]:
    """Generate certificates for all eligible students"""
    
    # Get eligible students
    eligible_students = await DatabaseOperations.find_many(
        "student_registrations",
        {
            "event.event_id": event_id,
            "certificate.eligible": True,
            "certificate.issued": False
        }
    )
    
    if not eligible_students:
        return {"batch_id": None, "message": "No eligible students found"}
    
    # Create certificate batch
    batch_id = f"BATCH_{event_id}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
    
    certificate_batch = {
        "_id": batch_id,
        "event_id": event_id,
        "generated_at": datetime.utcnow(),
        "eligible_count": len(eligible_students),
        "certificates": [],
        "status": "generating"
    }
    
    # Generate individual certificates
    for student_reg in eligible_students:
        certificate_id = f"CERT_{student_reg['student']['enrollment_no']}_{event_id}"
        
        # Update student registration
        await DatabaseOperations.update_one(
            "student_registrations",
            {"_id": student_reg["_id"]},
            {
                "$set": {
                    "certificate.issued": True,
                    "certificate.certificate_id": certificate_id,
                    "certificate.issued_at": datetime.utcnow(),
                    "certificate.batch_id": batch_id
                }
            }
        )
        
        certificate_batch["certificates"].append({
            "enrollment_no": student_reg["student"]["enrollment_no"],
            "certificate_id": certificate_id,
            "status": "generated"
        })
    
    # Save certificate batch
    await DatabaseOperations.insert_one("certificate_batches", certificate_batch)
    
    # Update batch status
    await DatabaseOperations.update_one(
        "certificate_batches",
        {"_id": batch_id},
        {"$set": {"status": "completed"}}
    )
    
    return {
        "batch_id": batch_id,
        "generated_count": len(eligible_students),
        "certificates": certificate_batch["certificates"]
    }
```

==============================================================================
PHASE 5: AUTOMATED CLEANUP WORKFLOW (Week 3, Days 1-2)
==============================================================================

5.1 DATA CLEANUP SERVICE
========================

File: `backend/services/event_cleanup_service.py`

```python
class EventCleanupService:
    """Service for managing event data cleanup after completion"""
    
    async def schedule_cleanup(self, event_id: str, delay_days: int = 30):
        """Schedule cleanup job for completed event"""
        
        cleanup_date = datetime.utcnow() + timedelta(days=delay_days)
        
        cleanup_job = {
            "event_id": event_id,
            "scheduled_for": cleanup_date,
            "status": "scheduled",
            "cleanup_tasks": [
                "archive_attendance_sessions",
                "cleanup_temporary_data",
                "archive_large_datasets",
                "update_statistics"
            ]
        }
        
        await DatabaseOperations.insert_one("cleanup_jobs", cleanup_job)
        
        # Schedule background task
        scheduler.add_job(
            self.execute_cleanup,
            'date',
            run_date=cleanup_date,
            args=[event_id],
            id=f"cleanup_{event_id}"
        )
    
    async def execute_cleanup(self, event_id: str):
        """Execute cleanup tasks for completed event"""
        
        try:
            logger.info(f"Starting cleanup for event {event_id}")
            
            # Task 1: Archive attendance sessions
            await self.archive_attendance_sessions(event_id)
            
            # Task 2: Clean temporary attendance configs
            await self.cleanup_attendance_configs(event_id)
            
            # Task 3: Archive large datasets
            await self.archive_large_datasets(event_id)
            
            # Task 4: Update final statistics
            await self.update_final_statistics(event_id)
            
            # Mark cleanup as completed
            await DatabaseOperations.update_one(
                "cleanup_jobs",
                {"event_id": event_id},
                {
                    "$set": {
                        "status": "completed",
                        "completed_at": datetime.utcnow()
                    }
                }
            )
            
            logger.info(f"Cleanup completed for event {event_id}")
            
        except Exception as e:
            logger.error(f"Cleanup failed for event {event_id}: {e}")
            await DatabaseOperations.update_one(
                "cleanup_jobs",
                {"event_id": event_id},
                {
                    "$set": {
                        "status": "failed",
                        "error": str(e),
                        "failed_at": datetime.utcnow()
                    }
                }
            )
    
    async def archive_attendance_sessions(self, event_id: str):
        """Archive detailed attendance session data"""
        
        # Get attendance config
        config = await DatabaseOperations.find_one(
            "attendance_configs",
            {"event_id": event_id}
        )
        
        if config:
            # Create archive document
            archive_doc = {
                "event_id": event_id,
                "original_config": config,
                "archived_at": datetime.utcnow(),
                "archive_type": "attendance_sessions"
            }
            
            await DatabaseOperations.insert_one("archived_data", archive_doc)
            
            # Remove detailed session data but keep summary
            simplified_config = {
                "event_id": event_id,
                "strategy": config["strategy"],
                "total_sessions": len(config.get("sessions", [])),
                "archived": True,
                "archived_at": datetime.utcnow()
            }
            
            await DatabaseOperations.replace_one(
                "attendance_configs",
                {"event_id": event_id},
                simplified_config
            )
    
    async def cleanup_attendance_configs(self, event_id: str):
        """Clean up temporary attendance data"""
        
        # Keep only essential attendance records
        await DatabaseOperations.update_many(
            "student_attendance_records",
            {"event_id": event_id},
            {
                "$unset": {
                    "sessions_attended.$.metadata": "",
                    "temporary_data": ""
                },
                "$set": {
                    "archived": True,
                    "archived_at": datetime.utcnow()
                }
            }
        )
```

==============================================================================
PHASE 6: DB ADMIN MONITORING (Week 3, Days 3-5)
==============================================================================

6.1 DATABASE HEALTH MONITORING
==============================

File: `backend/api/v1/admin_dashboard.py`

```python
@router.get("/database/health")
async def get_database_health(
    current_user = Depends(get_current_admin)
):
    """Comprehensive database health monitoring"""
    
    health_data = {
        "collections": {},
        "indexes": {},
        "performance": {},
        "cleanup_status": {},
        "system_metrics": {}
    }
    
    # Collection health
    for collection_name in ["student_registrations", "student_attendance_records", "events"]:
        stats = await get_collection_stats(collection_name)
        health_data["collections"][collection_name] = {
            "document_count": stats["count"],
            "average_size": stats["avgObjSize"],
            "total_size": stats["size"],
            "index_count": stats["nindexes"]
        }
    
    # Index performance
    for collection_name in ["student_registrations"]:
        index_stats = await get_index_performance(collection_name)
        health_data["indexes"][collection_name] = index_stats
    
    # Query performance metrics
    health_data["performance"] = await get_query_performance_metrics()
    
    # Cleanup job status
    cleanup_jobs = await DatabaseOperations.find_many(
        "cleanup_jobs",
        {"status": {"$in": ["scheduled", "running", "failed"]}},
        limit=10
    )
    health_data["cleanup_status"] = {
        "pending_jobs": len([j for j in cleanup_jobs if j["status"] == "scheduled"]),
        "failed_jobs": len([j for j in cleanup_jobs if j["status"] == "failed"]),
        "recent_jobs": cleanup_jobs
    }
    
    return health_data

@router.get("/system/analytics")
async def get_system_analytics(
    current_user = Depends(get_current_admin)
):
    """System-wide analytics and usage patterns"""
    
    # Registration trends
    registration_trends = await DatabaseOperations.aggregate(
        "student_registrations",
        [
            {
                "$group": {
                    "_id": {
                        "year": {"$year": "$registration.registered_at"},
                        "month": {"$month": "$registration.registered_at"}
                    },
                    "count": {"$sum": 1}
                }
            },
            {"$sort": {"_id.year": -1, "_id.month": -1}},
            {"$limit": 12}
        ]
    )
    
    # Event completion rates
    event_completion = await DatabaseOperations.aggregate(
        "events",
        [
            {
                "$group": {
                    "_id": "$status",
                    "count": {"$sum": 1}
                }
            }
        ]
    )
    
    # Certificate issuance rates
    certificate_stats = await DatabaseOperations.aggregate(
        "student_registrations",
        [
            {
                "$group": {
                    "_id": None,
                    "total_registrations": {"$sum": 1},
                    "certificate_eligible": {
                        "$sum": {"$cond": ["$certificate.eligible", 1, 0]}
                    },
                    "certificates_issued": {
                        "$sum": {"$cond": ["$certificate.issued", 1, 0]}
                    }
                }
            }
        ]
    )
    
    return {
        "registration_trends": registration_trends,
        "event_completion_rates": event_completion,
        "certificate_statistics": certificate_stats[0] if certificate_stats else {},
        "system_performance": await get_system_performance_metrics()
    }

@router.post("/cleanup/execute")
async def execute_manual_cleanup(
    cleanup_request: ManualCleanupRequest,
    current_user = Depends(get_current_admin)
):
    """Execute manual cleanup for specific events or data types"""
    
    cleanup_service = EventCleanupService()
    
    if cleanup_request.event_ids:
        results = []
        for event_id in cleanup_request.event_ids:
            result = await cleanup_service.execute_cleanup(event_id)
            results.append({
                "event_id": event_id,
                "success": result["success"],
                "message": result["message"]
            })
        return {"cleanup_results": results}
    
    elif cleanup_request.cleanup_type == "expired_sessions":
        # Clean up expired attendance sessions
        cutoff_date = datetime.utcnow() - timedelta(days=cleanup_request.days_old)
        result = await cleanup_expired_attendance_sessions(cutoff_date)
        return result
    
    elif cleanup_request.cleanup_type == "orphaned_data":
        # Clean up orphaned data
        result = await cleanup_orphaned_data()
        return result
    
    else:
        raise HTTPException(status_code=400, detail="Invalid cleanup request")
```

==============================================================================
SUCCESS CRITERIA AND TESTING
==============================================================================

FUNCTIONAL TESTING:
==================
✅ Student can view complete participation dashboard
✅ Organizer can monitor events in real-time
✅ Certificate generation works automatically
✅ Event completion workflow executes properly
✅ Data cleanup removes unnecessary data while preserving history

PERFORMANCE TESTING:
====================
✅ Student dashboard loads in <1 second
✅ Organizer dashboard loads in <2 seconds
✅ Real-time attendance updates in <500ms
✅ Certificate generation completes in <2 seconds for 100 students
✅ Database queries stay under 200ms with proper indexing

INTEGRATION TESTING:
====================
✅ All APIs work with existing authentication
✅ Dynamic attendance system integrates seamlessly
✅ Role-based access controls work properly
✅ Data consistency maintained across all operations

==============================================================================
DEPLOYMENT CHECKLIST
==============================================================================

PRE-DEPLOYMENT:
□ Backup existing database
□ Test migration scripts on staging environment
□ Verify all indexes are created properly
□ Test role-based access controls

DEPLOYMENT:
□ Execute database migration
□ Update service layer collection references
□ Deploy new API endpoints
□ Update frontend to use new dashboard APIs

POST-DEPLOYMENT:
□ Monitor system performance
□ Verify real-time updates work
□ Test complete event lifecycle
□ Confirm cleanup jobs are scheduled properly

==============================================================================
MAINTENANCE AND MONITORING
==============================================================================

DAILY MONITORING:
- Database performance metrics
- Failed cleanup jobs
- Certificate generation errors
- Real-time dashboard responsiveness

WEEKLY MONITORING:
- Data growth trends
- Query performance analysis
- User activity patterns
- System resource usage

MONTHLY MAINTENANCE:
- Archive old event data
- Optimize database indexes
- Review and update cleanup policies
- Performance tuning based on usage patterns

This implementation plan provides a complete event lifecycle while maintaining the simplicity and performance requirements of event_lifecycle.txt. The focus is on practical, role-based information access with automated cleanup to keep the system efficient.
